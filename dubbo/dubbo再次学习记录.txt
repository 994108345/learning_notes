启动时检查
	dubbo缺省会在启动时检查依赖的服务是否可用。不可用时抛出异常。阻止Spring完成初始化、默认check="true"
	因为有时候，我们并不是在dubbo启动的时候，服务就启动了。所以要关闭该配置，即check = "false"
	Spring配置check
		关闭某个服务的启动时检查 (没有提供者时报错)：
			<dubbo:reference interface="com.foo.BarService" check="false" /> //在consumer消费者配置文件里面配置，粒度的这个消费服务
			
		关闭所有服务的启动时检查 (没有提供者时报错)：
			<dubbo:consumer check="false" /> //在消费者配置文件里面配置，粒度是该配置文件的所有被消费的服务
			
		关闭注册中心启动时检查 (注册订阅失败时报错)：
			<dubbo:registry check="false" /> //在consumer和provider配置文件里都有，即检查该注册中心服务是否开启
			
		通过 dubbo.properties
			dubbo.reference.com.foo.BarService.check=false
			dubbo.reference.check=false
			dubbo.consumer.check=false
			dubbo.registry.check=false
			
		通过 -D 参数
			java -Ddubbo.reference.com.foo.BarService.check=false
			java -Ddubbo.reference.check=false
			java -Ddubbo.consumer.check=false 
			java -Ddubbo.registry.check=false
		配置的含义
			dubbo.reference.check=false，强制改变所有 reference 的 check 值，就算配置中有声明，也会被覆盖。

			dubbo.consumer.check=false，是设置 check 的缺省值，如果配置中有显式的声明，如：<dubbo:reference check="true"/>，不会受影响。

			dubbo.registry.check=false，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。

集群容错

	各节点关系：
	这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息
	Directory 代表多个 Invoker，可以把它看成 List<Invoker> ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更
	Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个
	Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等
	LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选
	
	集群容错模式
	
		Failover Cluster：
			失败自动切换，当出现失败，重试其它服务器 [1]。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。
			重试次数配置如下：
			<dubbo:service retries="2" />
			或
			<dubbo:reference retries="2" />
			或
			<dubbo:reference>
				<dubbo:method name="findFoo" retries="2" />
			</dubbo:reference>
			
		Failfast Cluster
			快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。

		Failsafe Cluster
			失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。

		Failback Cluster
			失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。

		Forking Cluster
			并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。

		Broadcast Cluster
			广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。
			
	集群模式配置
		按照以下示例在服务提供方和消费方配置集群模式
		
		<dubbo:service cluster="failsafe" />
		
		或

		<dubbo:reference cluster="failsafe" />
		
负载均衡
	dubbo默认的random随机调用。
	负载均衡策略
		Random LoadBalance
			随机，按权重设置随机概率。
			在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。
		RoundRobin LoadBalance
			轮循，按公约后的权重设置轮循比率。
			存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。
		LeastActive LoadBalance
			最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
			使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
		ConsistentHash LoadBalance
			一致性 Hash，相同参数的请求总是发到同一提供者。
			当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
			算法参见：http://en.wikipedia.org/wiki/Consistent_hashing
			缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1" />
			缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320" />
	配置
		服务端服务级别
			<dubbo:service interface="..." loadbalance="roundrobin" />
		客户端服务级别
			<dubbo:reference interface="..." loadbalance="roundrobin" />
		服务端方法级别
			<dubbo:service interface="...">
				<dubbo:method name="..." loadbalance="roundrobin"/>
			</dubbo:service>
		客户端方法级别
			<dubbo:reference interface="...">
				<dubbo:method name="..." loadbalance="roundrobin"/>
			</dubbo:reference>	
			
线程模型
	如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。

	但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。

	如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。

	dubbo-protocol

	因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:

	<dubbo:protocol name="dubbo" dispatcher="all" threadpool="fixed" threads="100" />
	Dispatcher

	all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。
	direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。
	message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。
	execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。
	connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。
	ThreadPool

	fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)
	cached 缓存线程池，空闲一分钟自动删除，需要时重建。
	limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。
	eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)

直接提供者
	在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。


	通过 XML 配置
		如果是线上需求需要点对点，可在 <dubbo:reference> 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下 [1]：

			<dubbo:reference id="xxxService" interface="com.alibaba.xxx.XxxService" url="dubbo://localhost:20890" />
	通过 -D 参数指定
		在 JVM 启动参数中加入-D参数映射服务地址 [2]，如：

		java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890
	通过文件映射
		如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 <dubbo:reference> 中的配置 [3]，如：

		java -Ddubbo.resolve.file=xxx.properties
		然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：

		com.alibaba.xxx.XxxService=dubbo://localhost:20890
		注意 为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。	

只订阅		
	为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。

	可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。	
		禁用注册配置

		<dubbo:registry address="10.20.153.10:9090" register="false" />
		或者

		<dubbo:registry address="10.20.153.10:9090?register=false" />	
只注册
	如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。

	禁用订阅配置

	<dubbo:registry id="hzRegistry" address="10.20.153.10:9090" />
	<dubbo:registry id="qdRegistry" address="10.20.141.150:9090" subscribe="false" />
	或者

	<dubbo:registry id="hzRegistry" address="10.20.153.10:9090" />
	<dubbo:registry id="qdRegistry" address="10.20.141.150:9090?subscribe=false" />

静态服务（！）
	有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式。

	<dubbo:registry address="10.20.141.150:9090" dynamic="false" />
	或者

	<dubbo:registry address="10.20.141.150:9090?dynamic=false" />
	服务提供者初次注册时为禁用状态，需人工启用。断线时，将不会被自动删除，需人工禁用。

	如果是一个第三方独立提供者，比如 memcached，可以直接向注册中心写入提供者地址信息，消费者正常使用 [1]：

	RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
	Registry registry = registryFactory.getRegistry(URL.valueOf("zookeeper://10.20.153.10:2181"));
	registry.register(URL.valueOf("memcached://10.20.153.11/com.foo.BarService?category=providers&dynamic=false&application=foo"));
	通常由脚本监控中心页面等调用 ↩︎
	
多协议（！）
	Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。
	不同服务不同协议
		不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"> 
			<dubbo:application name="world"  />
			<dubbo:registry id="registry" address="10.20.141.150:9090" username="admin" password="hello1234" />
			<!-- 多协议配置 -->
			<dubbo:protocol name="dubbo" port="20880" />
			<dubbo:protocol name="rmi" port="1099" />
			<!-- 使用dubbo协议暴露服务 -->
			<dubbo:service interface="com.alibaba.hello.api.HelloService" version="1.0.0" ref="helloService" protocol="dubbo" />
			<!-- 使用rmi协议暴露服务 -->
			<dubbo:service interface="com.alibaba.hello.api.DemoService" version="1.0.0" ref="demoService" protocol="rmi" /> 
		</beans>
	
	多协议暴露服务
		需要与 http 客户端互操作

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">
			<dubbo:application name="world"  />
			<dubbo:registry id="registry" address="10.20.141.150:9090" username="admin" password="hello1234" />
			<!-- 多协议配置 -->
			<dubbo:protocol name="dubbo" port="20880" />
			<dubbo:protocol name="hessian" port="8080" />
			<!-- 使用多个协议暴露服务 -->
			<dubbo:service id="helloService" interface="com.alibaba.hello.api.HelloService" version="1.0.0" protocol="dubbo,hessian" />
		</beans>
		
多注册中心
	Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。另外，注册中心是支持自定义扩展的 [1]。

	多注册中心注册
		比如：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">
			<dubbo:application name="world"  />
			<!-- 多注册中心配置 -->
			<dubbo:registry id="hangzhouRegistry" address="10.20.141.150:9090" />
			<dubbo:registry id="qingdaoRegistry" address="10.20.141.151:9010" default="false" />
			<!-- 向多个注册中心注册 -->
			<dubbo:service interface="com.alibaba.hello.api.HelloService" version="1.0.0" ref="helloService" registry="hangzhouRegistry,qingdaoRegistry" />
		</beans>
		不同服务使用不同注册中心
		比如：CRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">
			<dubbo:application name="world"  />
			<!-- 多注册中心配置 -->
			<dubbo:registry id="chinaRegistry" address="10.20.141.150:9090" />
			<dubbo:registry id="intlRegistry" address="10.20.154.177:9010" default="false" />
			<!-- 向中文站注册中心注册 -->
			<dubbo:service interface="com.alibaba.hello.api.HelloService" version="1.0.0" ref="helloService" registry="chinaRegistry" />
			<!-- 向国际站注册中心注册 -->
			<dubbo:service interface="com.alibaba.hello.api.DemoService" version="1.0.0" ref="demoService" registry="intlRegistry" />
		</beans>
		
	多注册中心引用
		比如：CRM 需同时调用中文站和国际站的 PC2 服务，PC2 在中文站和国际站均有部署，接口及版本号都一样，但连的数据库不一样。

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">
			<dubbo:application name="world"  />
			<!-- 多注册中心配置 -->
			<dubbo:registry id="chinaRegistry" address="10.20.141.150:9090" />
			<dubbo:registry id="intlRegistry" address="10.20.154.177:9010" default="false" />
			<!-- 引用中文站服务 -->
			<dubbo:reference id="chinaHelloService" interface="com.alibaba.hello.api.HelloService" version="1.0.0" registry="chinaRegistry" />
			<!-- 引用国际站站服务 -->
			<dubbo:reference id="intlHelloService" interface="com.alibaba.hello.api.HelloService" version="1.0.0" registry="intlRegistry" />
		</beans>
		如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">
			<dubbo:application name="world"  />
			<!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，同一注册中心的多个集群地址用逗号分隔 -->
			<dubbo:registry address="10.20.141.150:9090|10.20.154.177:9010" />
			<!-- 引用服务 -->
			<dubbo:reference id="helloService" interface="com.alibaba.hello.api.HelloService" version="1.0.0" />
		</beans>
		
服务分组
	当一个接口有多种实现时，可以用 group 区分。

	服务
		<dubbo:service group="feedback" interface="com.xxx.IndexService" />
		<dubbo:service group="member" interface="com.xxx.IndexService" />
	引用
		<dubbo:reference id="feedbackIndexService" group="feedback" interface="com.xxx.IndexService" />
		<dubbo:reference id="memberIndexService" group="member" interface="com.xxx.IndexService" />
	任意组 [1]：

		<dubbo:reference id="barService" interface="com.foo.BarService" group="*" />
			
多版本（！）
	
	当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。

	可以按照以下的步骤进行版本迁移：

	在低压力时间段，先升级一半提供者为新版本
	再将所有消费者升级为新版本
	然后将剩下的一半提供者升级为新版本
	老版本服务提供者配置：

	<dubbo:service interface="com.foo.BarService" version="1.0.0" />
	新版本服务提供者配置：

	<dubbo:service interface="com.foo.BarService" version="2.0.0" />
	老版本服务消费者配置：

	<dubbo:reference id="barService" interface="com.foo.BarService" version="1.0.0" />
	新版本服务消费者配置：

	<dubbo:reference id="barService" interface="com.foo.BarService" version="2.0.0" />
	如果不需要区分版本，可以按照以下的方式配置 [1]：

	<dubbo:reference id="barService" interface="com.foo.BarService" version="*" />
	
分组聚合

	按组合并返回结果 [1]，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。

	相关代码可以参考 dubbo 项目中的示例

	配置
	搜索所有分组

	<dubbo:reference interface="com.xxx.MenuService" group="*" merger="true" />
	合并指定分组

	<dubbo:reference interface="com.xxx.MenuService" group="aaa,bbb" merger="true" />
	指定方法合并结果，其它未指定的方法，将只调用一个 Group

	<dubbo:reference interface="com.xxx.MenuService" group="*">
		<dubbo:method name="getMenuItems" merger="true" />
	</dubbo:service>
	某个方法不合并结果，其它都合并结果

	<dubbo:reference interface="com.xxx.MenuService" group="*" merger="true">
		<dubbo:method name="getMenuItems" merger="false" />
	</dubbo:service>
	指定合并策略，缺省根据返回值类型自动匹配，如果同一类型有两个合并器时，需指定合并器的名称 [2]

	<dubbo:reference interface="com.xxx.MenuService" group="*">
		<dubbo:method name="getMenuItems" merger="mymerge" />
	</dubbo:service>
	指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型本身

	<dubbo:reference interface="com.xxx.MenuService" group="*">
		<dubbo:method name="getMenuItems" merger=".addAll" />
	</dubbo:service>
	
回声测试
	回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。
	所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。

	Spring 配置：

		<dubbo:reference id="memberService" interface="com.xxx.MemberService" />
	代码：

		// 远程服务引用
		MemberService memberService = ctx.getBean("memberService"); 
		 
		EchoService echoService = (EchoService) memberService; // 强制转型为EchoService

		// 回声测试可用性
		String status = echoService.$echo("OK"); 
		 
		assert(status.equals("OK"));
		
上下文信息
	上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 schema 配置参考手册 中的对应URL参数一列。

	RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。
	
	服务消费方
		// 远程调用
		xxxService.xxx();
		// 本端是否为消费端，这里会返回true
		boolean isConsumerSide = RpcContext.getContext().isConsumerSide();
		// 获取最后一次调用的提供方IP地址
		String serverIP = RpcContext.getContext().getRemoteHost();
		// 获取当前服务配置信息，所有配置信息都将转换为URL的参数
		String application = RpcContext.getContext().getUrl().getParameter("application");
		// 注意：每发起RPC调用，上下文状态会变化
		yyyService.yyy();
		
	服务提供方
		public class XxxServiceImpl implements XxxService {
		 
			public void xxx() {
				// 本端是否为提供端，这里会返回true
				boolean isProviderSide = RpcContext.getContext().isProviderSide();
				// 获取调用方IP地址
				String clientIP = RpcContext.getContext().getRemoteHost();
				// 获取当前服务配置信息，所有配置信息都将转换为URL的参数
				String application = RpcContext.getContext().getUrl().getParameter("application");
				// 注意：每发起RPC调用，上下文状态会变化
				yyyService.yyy();
				// 此时本端变成消费端，这里会返回false
				boolean isProviderSide = RpcContext.getContext().isProviderSide();
			} 
		}	
		
隐式参数
	可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递。 [1]
	
	在服务消费方端设置隐式参数
		setAttachment 设置的 KV 对，在完成下面一次远程调用会被清空，即多次远程调用要多次设置。

		RpcContext.getContext().setAttachment("index", "1"); // 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，用于框架集成，不建议常规业务使用
		xxxService.xxx(); // 远程调用
		// ...
		
	在服务提供方端获取隐式参数
		public class XxxServiceImpl implements XxxService {
		 
			public void xxx() {
				// 获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用
				String index = RpcContext.getContext().getAttachment("index"); 
			}
		}
	注意：path, group, version, dubbo, token, timeout 几个 key 是保留字段，请使用其它值

异步调用：
	基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。 [1]
	在 consumer.xml 中配置：

		<dubbo:reference id="fooService" interface="com.alibaba.foo.FooService">
			  <dubbo:method name="findFoo" async="true" />
		</dubbo:reference>
		<dubbo:reference id="barService" interface="com.alibaba.bar.BarService">
			  <dubbo:method name="findBar" async="true" />
		</dubbo:reference>
		
	调用代码:
		// 此调用会立即返回null
		fooService.findFoo(fooId);
		// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future
		Future<Foo> fooFuture = RpcContext.getContext().getFuture(); 
		 
		// 此调用会立即返回null
		barService.findBar(barId);
		// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future
		Future<Bar> barFuture = RpcContext.getContext().getFuture(); 
		 
		// 此时findFoo和findBar的请求同时在执行，客户端不需要启动多线程来支持并行，而是借助NIO的非阻塞完成
		 
		// 如果foo已返回，直接拿到返回值，否则线程wait住，等待foo返回后，线程会被notify唤醒
		Foo foo = fooFuture.get(); 
		// 同理等待bar返回
		Bar bar = barFuture.get(); 
		 
		// 如果foo需要5秒返回，bar需要6秒返回，实际只需等6秒，即可获取到foo和bar，进行接下来的处理。
			
	你也可以设置是否等待消息发出： [2]
		sent="true" 等待消息发出，消息发送失败将抛出异常。
		sent="false" 不等待消息发出，将消息放入 IO 队列，即刻返回。
		<dubbo:method name="findFoo" async="true" sent="true" />		
			
	如果你只是想异步，完全忽略返回值，可以配置 return="false"，以减少 Future 对象的创建和管理成本：
		<dubbo:method name="findFoo" async="true" return="false" />	

本地调用
	本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。
	
	配置
	
	定义 injvm 协议

		<dubbo:protocol name="injvm" />
	设置默认协议

		<dubbo:provider protocol="injvm" />
	设置服务协议

		<dubbo:service protocol="injvm" />
	优先使用 injvm

		<dubbo:consumer injvm="true" .../>
		<dubbo:provider injvm="true" .../>
		或

		<dubbo:reference injvm="true" .../>
		<dubbo:service injvm="true" .../>
	注意：服务暴露与服务引用都需要声明 injvm="true"

	自动暴露、引用本地服务
	从 2.2.0 开始，每个服务默认都会在本地暴露。在引用服务的时候，默认优先引用本地服务。如果希望引用远程服务可以使用一下配置强制引用远程服务。

		<dubbo:reference ... scope="remote" />	
		
参数回调
	参数回调方式与调用本地 callback 或 listener 相同，只需要在 Spring 的配置文件中声明哪个参数是 callback 类型即可。Dubbo 将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑 [1]。可以参考 dubbo 项目中的示例代码。
	
	服务接口示例
		CallbackService.java
		package com.callback;
		 
		public interface CallbackService {
			void addListener(String key, CallbackListener listener);
		}
		CallbackListener.java
		package com.callback;
		 
		public interface CallbackListener {
			void changed(String msg);
		}
		
	服务提供者接口实现示例
		package com.callback.impl;
		 
		import java.text.SimpleDateFormat;
		import java.util.Date;
		import java.util.Map;
		import java.util.concurrent.ConcurrentHashMap;
		 
		import com.callback.CallbackListener;
		import com.callback.CallbackService;
		 
		public class CallbackServiceImpl implements CallbackService {
			 
			private final Map<String, CallbackListener> listeners = new ConcurrentHashMap<String, CallbackListener>();
		  
			public CallbackServiceImpl() {
				Thread t = new Thread(new Runnable() {
					public void run() {
						while(true) {
							try {
								for(Map.Entry<String, CallbackListener> entry : listeners.entrySet()){
								   try {
									   entry.getValue().changed(getChanged(entry.getKey()));
								   } catch (Throwable t) {
									   listeners.remove(entry.getKey());
								   }
								}
								Thread.sleep(5000); // 定时触发变更通知
							} catch (Throwable t) { // 防御容错
								t.printStackTrace();
							}
						}
					}
				});
				t.setDaemon(true);
				t.start();
			}
		  
			public void addListener(String key, CallbackListener listener) {
				listeners.put(key, listener);
				listener.changed(getChanged(key)); // 发送变更通知
			}
			 
			private String getChanged(String key) {
				return "Changed: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
			}
		}
		
	服务提供者配置示例
		<bean id="callbackService" class="com.callback.impl.CallbackServiceImpl" />
		<dubbo:service interface="com.callback.CallbackService" ref="callbackService" connections="1" callbacks="1000">
			<dubbo:method name="addListener">
				<dubbo:argument index="1" callback="true" />
				<!--也可以通过指定类型的方式-->
				<!--<dubbo:argument type="com.demo.CallbackListener" callback="true" />-->
			</dubbo:method>
		</dubbo:service>
		
	服务消费者配置示例
		<dubbo:reference id="callbackService" interface="com.callback.CallbackService" />
		
	服务消费者调用示例
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("classpath:consumer.xml");
		context.start();
		 
		CallbackService callbackService = (CallbackService) context.getBean("callbackService");
		 
		callbackService.addListener("http://10.20.160.198/wiki/display/dubbo/foo.bar", new CallbackListener(){
			public void changed(String msg) {
				System.out.println("callback1:" + msg);
			}
		});

事件通知
	在调用之前、调用之后、出现异常时，会触发 oninvoke、onreturn、onthrow 三个事件，可以配置当事件发生时，通知哪个类的哪个方法 [1]。
	
	服务提供者与消费者共享服务接口
		interface IDemoService {
			public Person get(int id);
		}
	
	服务提供者实现
		class NormalDemoService implements IDemoService {
			public Person get(int id) {
				return new Person(id, "charles`son", 4);
			}
		}
		
	服务提供者配置
		<dubbo:application name="rpc-callback-demo" />
		<dubbo:registry address="http://10.20.160.198/wiki/display/dubbo/10.20.153.186" />
		<bean id="demoService" class="com.alibaba.dubbo.callback.implicit.NormalDemoService" />
		<dubbo:service interface="com.alibaba.dubbo.callback.implicit.IDemoService" ref="demoService" version="1.0.0" group="cn"/>
			
	服务消费者 Callback 接口
		interface Notify {
			public void onreturn(Person msg, Integer id);
			public void onthrow(Throwable ex, Integer id);
		}
	
	服务消费者 Callback 实现
		class NotifyImpl implements Notify {
			public Map<Integer, Person>    ret    = new HashMap<Integer, Person>();
			public Map<Integer, Throwable> errors = new HashMap<Integer, Throwable>();
			
			public void onreturn(Person msg, Integer id) {
				System.out.println("onreturn:" + msg);
				ret.put(id, msg);
			}
			
			public void onthrow(Throwable ex, Integer id) {
				errors.put(id, ex);
			}
		}
		
	服务消费者 Callback 配置
		<bean id ="demoCallback" class = "com.alibaba.dubbo.callback.implicit.NofifyImpl" />
		<dubbo:reference id="demoService" interface="com.alibaba.dubbo.callback.implicit.IDemoService" version="1.0.0" group="cn" >
			  <dubbo:method name="get" async="true" onreturn = "demoCallback.onreturn" onthrow="demoCallback.onthrow" />
		</dubbo:reference>
		
	callback 与 async 功能正交分解，async=true 表示结果是否马上返回，onreturn 表示是否需要回调。

	两者叠加存在以下几种组合情况 [2]：

	异步回调模式：async=true onreturn="xxx"
	同步回调模式：async=false onreturn="xxx"
	异步无回调 ：async=true
	同步无回调 ：async=false
	
	测试代码
	IDemoService demoService = (IDemoService) context.getBean("demoService");
	NofifyImpl notify = (NofifyImpl) context.getBean("demoCallback");
	int requestId = 2;
	Person ret = demoService.get(requestId);
	Assert.assertEquals(null, ret);
	//for Test：只是用来说明callback正常被调用，业务具体实现自行决定.
	for (int i = 0; i < 10; i++) {
		if (!notify.ret.containsKey(requestId)) {
			Thread.sleep(200);
		} else {
			break;
		}
	}
	Assert.assertEquals(requestId, notify.ret.get(requestId).getId());
	注意：

	oninvoke方法：
		必须具有与真实的被调用方法sayHello相同的入参列表：例如，oninvoke(String name)
	onreturn方法：
		至少要有一个入参且第一个入参必须与sayHello的返回类型相同，接收返回结果：例如，onreturnWithoutParam(String result)
		可以有多个参数，多个参数的情况下，第一个后边的所有参数都是用来接收sayHello入参的：例如， onreturn(String result, String name)
	onthrow方法：
		至少要有一个入参且第一个入参类型为Throwable或其子类，接收返回结果；例如，onthrow(Throwable ex)
		可以有多个参数，多个参数的情况下，第一个后边的所有参数都是用来接收sayHello入参的：例如，onthrow(Throwable ex, String name)
	如果是consumer在调用provider的过程中，出现异常时不会走onthrow方法的，onthrow方法只会在provider返回的RpcResult中含有Exception对象时，才会执行。（dubbo中下层服务的Exception会被放在响应RpcResult的exception对象中传递给上层服务）
	
本地存根
	远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub [1]，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。
	
	在 spring 配置文件中按以下方式配置：

		<dubbo:service interface="com.foo.BarService" stub="true" />
		或

		<dubbo:service interface="com.foo.BarService" stub="com.foo.BarServiceStub" />
	
	提供 Stub 的实现 [2]：

		package com.foo;
		public class BarServiceStub implements BarService { 
			private final BarService barService;
			
			// 构造函数传入真正的远程代理对象
			public (BarService barService) {
				this.barService = barService;
			}
		 
			public String sayHello(String name) {
				// 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等
				try {
					return barService.sayHello(name);
				} catch (Exception e) {
					// 你可以容错，可以做任何AOP拦截事项
					return "容错数据";
				}
			}
		}
	Stub 必须有可传入 Proxy 的构造函数。 ↩︎

		在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数 ↩︎
	
本地伪装
	本地伪装 [1] 通常用于服务降级，比如某验权服务，当服务提供方全部挂掉后，客户端不抛出异常，而是通过 Mock 数据返回授权失败。
	
	在 spring 配置文件中按以下方式配置：

		<dubbo:reference interface="com.foo.BarService" mock="true" />
		或

		<dubbo:reference interface="com.foo.BarService" mock="com.foo.BarServiceMock" />
		
	在工程中提供 Mock 实现 [2]：

		package com.foo;
		public class BarServiceMock implements BarService {
			public String sayHello(String name) {
				// 你可以伪造容错数据，此方法只在出现RpcException时被执行
				return "容错数据";
			}
		}
		
	如果服务的消费方经常需要 try-catch 捕获异常，如：

		Offer offer = null;
		try {
			offer = offerService.findOffer(offerId);
		} catch (RpcException e) {
		   logger.error(e);
		}
		
	请考虑改为 Mock 实现，并在 Mock 实现中 return null。如果只是想简单的忽略异常，在 2.0.11 以上版本可用：

		<dubbo:reference interface="com.foo.BarService" mock="return null" />
		
	Mock 是 Stub 的一个子集，便于服务提供方在客户端执行容错逻辑，因经常需要在出现 RpcException (比如网络失败，超时等)时进行容错，而在出现业务异常(比如登录用户名密码错误)时不需要容错，如果用 Stub，可能就需要捕获并依赖 RpcException 类，而用 Mock 就可以不依赖 RpcException，因为它的约定就是只有出现 RpcException 时才执行。 ↩︎

	在 interface 旁放一个 Mock 实现，它实现 BarService 接口，并有一个无参构造函数 ↩︎
	
	
延迟暴露

	如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。

	延迟 5 秒暴露服务
		<dubbo:service delay="5000" />
		
	延迟到 Spring 初始化完成后，再暴露服务 [1]
		<dubbo:service delay="-1" />
		
	Spring 2.x 初始化死锁问题
		触发条件
		在 Spring 解析到 <dubbo:service /> 时，就已经向外暴露了服务，而 Spring 还在接着初始化其它 Bean。如果这时有请求进来，并且服务的实现类里有调用 applicationContext.getBean() 的用法。

		请求线程的 applicationContext.getBean() 调用，先同步 singletonObjects 判断 Bean 是否存在，不存在就同步 beanDefinitionMap 进行初始化，并再次同步 singletonObjects 写入 Bean 实例缓存。

		deadlock

		而 Spring 初始化线程，因不需要判断 Bean 的存在，直接同步 beanDefinitionMap 进行初始化，并同步 singletonObjects 写入 Bean 实例缓存。

		/user-guide/images/lock-init-context.jpg

		这样就导致 getBean 线程，先锁 singletonObjects，再锁 beanDefinitionMap，再次锁 singletonObjects。
		而 Spring 初始化线程，先锁 beanDefinitionMap，再锁 singletonObjects。反向锁导致线程死锁，不能提供服务，启动不了。

		规避办法
			强烈建议不要在服务的实现类中有 applicationContext.getBean() 的调用，全部采用 IoC 注入的方式使用 Spring的Bean。
			如果实在要调 getBean()，可以将 Dubbo 的配置放在 Spring 的最后加载。
			如果不想依赖配置顺序，可以使用 <dubbo:provider delay=”-1” />，使 Dubbo 在 Spring 容器初始化完后，再暴露服务。
			如果大量使用 getBean()，相当于已经把 Spring 退化为工厂模式在用，可以将 Dubbo 的服务隔离单独的 Spring 容器。
	
并发控制

	配置样例
	
	样例 1
		限制 com.foo.BarService 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：

		<dubbo:service interface="com.foo.BarService" executes="10" />
	
	样例 2
		限制 com.foo.BarService 的 sayHello 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：

		<dubbo:service interface="com.foo.BarService">
			<dubbo:method name="sayHello" executes="10" />
		</dubbo:service>
	
	样例 3
		限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：

		<dubbo:service interface="com.foo.BarService" actives="10" />
		或

		<dubbo:reference interface="com.foo.BarService" actives="10" />
		
	样例 4
		限制 com.foo.BarService 的 sayHello 方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：

		<dubbo:service interface="com.foo.BarService">
			<dubbo:method name="sayHello" actives="10" />
		</dubbo:service>
		或

		<dubbo:reference interface="com.foo.BarService">
			<dubbo:method name="sayHello" actives="10" />
		</dubbo:service>
	如果 <dubbo:service> 和 <dubbo:reference> 都配了actives，<dubbo:reference> 优先，参见：配置的覆盖策略。

		Load Balance 均衡
		配置服务的客户端的 loadbalance 属性为 leastactive，此 Loadbalance 会调用并发数最小的 Provider（Consumer端并发数）。

		<dubbo:reference interface="com.foo.BarService" loadbalance="leastactive" />
		或

		<dubbo:service interface="com.foo.BarService" loadbalance="leastactive" />
	
连接控制

	服务端连接控制
	
		限制服务器端接受的连接不能超过 10 个 [1]：

			<dubbo:provider protocol="dubbo" accepts="10" />
			或

			<dubbo:protocol name="dubbo" accepts="10" />
		
	客户端连接控制
	
		限制客户端服务使用连接不能超过 10 个 [2]：

			<dubbo:reference interface="com.foo.BarService" connections="10" />
			或

			<dubbo:service interface="com.foo.BarService" connections="10" />
			如果 <dubbo:service> 和 <dubbo:reference> 都配了 connections，<dubbo:reference> 优先，参见：配置的覆盖策略

延迟连接

	延迟连接用于减少长连接数。当有调用发起时，再创建长连接。[1]

	<dubbo:protocol name="dubbo" lazy="true" />	
	
粘滞连接

	粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。

	粘滞连接将自动开启延迟连接，以减少长连接数。

	<dubbo:protocol name="dubbo" sticky="true" />	
		
令牌验证

	通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者	
	可以全局设置开启令牌验证：

		<!--随机token令牌，使用UUID生成-->
		<dubbo:provider interface="com.foo.BarService" token="true" />
		或

		<!--固定token令牌，相当于密码-->
		<dubbo:provider interface="com.foo.BarService" token="123456" />
		也可在服务级别设置：

		<!--随机token令牌，使用UUID生成-->
		<dubbo:service interface="com.foo.BarService" token="true" />
		或

		<!--固定token令牌，相当于密码-->
		<dubbo:service interface="com.foo.BarService" token="123456" />
		还可在协议级别设置：

		<!--随机token令牌，使用UUID生成-->
		<dubbo:protocol name="dubbo" token="true" />
		或

		<!--固定token令牌，相当于密码-->
		<dubbo:protocol name="dubbo" token="123456" />
			
路由规则

	路由规则 [1] 决定一次 dubbo 服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展 [2]。

	写入路由规则
	
		向注册中心写入路由规则的操作通常由监控中心或治理中心的页面完成

		RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
		Registry registry = registryFactory.getRegistry(URL.valueOf("zookeeper://10.20.153.10:2181"));
		registry.register(URL.valueOf("condition://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("host = 10.20.153.10 => host = 10.20.153.11") + "));
		其中：

		condition:// 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。
		0.0.0.0 表示对所有 IP 地址生效，如果只想对某个 IP 的生效，请填入具体 IP，必填。
		com.foo.BarService 表示只对指定服务生效，必填。
		group=foo 对指定服务的指定group生效，不填表示对未配置group的指定服务生效
		version=1.0对指定服务的指定version生效，不填表示对未配置version的指定服务生效
		category=routers 表示该数据为动态配置类型，必填。
		dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。
		enabled=true 覆盖规则是否生效，可不填，缺省生效。
		force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。
		runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。
		priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。
		rule=URL.encode("host = 10.20.153.10 => host = 10.20.153.11") 表示路由规则的内容，必填。
		
	条件路由规则
	
		基于条件表达式的路由规则，如：host = 10.20.153.10 => host = 10.20.153.11

		规则：
		=> 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。
		=> 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。
		如果匹配条件为空，表示对所有消费方应用，如：=> host != 10.20.153.11
		如果过滤条件为空，表示禁止访问，如：host = 10.20.153.10 =>
		表达式：
		参数支持：

		服务调用信息，如：method, argument 等，暂不支持参数路由
		URL 本身的字段，如：protocol, host, port 等
		以及 URL 上的所有参数，如：application, organization 等
		条件支持：

		等号 = 表示"匹配"，如：host = 10.20.153.10
		不等号 != 表示"不匹配"，如：host != 10.20.153.10
		值支持：

		以逗号 , 分隔多个值，如：host != 10.20.153.10,10.20.153.11
		以星号 * 结尾，表示通配，如：host != 10.20.*
		以美元符 $ 开头，表示引用消费者参数，如：host = $host
		示例：
		排除预发布机：

		=> host != 172.22.3.91
		白名单 [3]：

		host != 10.20.153.10,10.20.153.11 =>
		黑名单：

		host = 10.20.153.10,10.20.153.11 =>
		服务寄宿在应用上，只暴露一部分的机器，防止整个集群挂掉：

		=> host = 172.22.3.1*,172.22.3.2*
		为重要应用提供额外的机器：

		application != kylin => host != 172.22.3.95,172.22.3.96
		读写分离：

		method = find*,list*,get*,is* => host = 172.22.3.94,172.22.3.95,172.22.3.96
		method != find*,list*,get*,is* => host = 172.22.3.97,172.22.3.98
		前后台分离：

		application = bops => host = 172.22.3.91,172.22.3.92,172.22.3.93
		application != bops => host = 172.22.3.94,172.22.3.95,172.22.3.96
		隔离不同机房网段：

		host != 172.22.3.* => host != 172.22.3.*
		提供者与消费者部署在同集群内，本机只访问本机的服务：

		=> host = $host
		
	脚本路由规则
	
		脚本路由规则 [4] 支持 JDK 脚本引擎的所有脚本，比如：javascript, jruby, groovy 等，通过 type=javascript 参数设置脚本类型，缺省为 javascript。

		"script://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("（function route(invokers) { ... } (invokers)）")
		基于脚本引擎的路由规则，如：

		（function route(invokers) {
			var result = new java.util.ArrayList(invokers.size());
			for (i = 0; i < invokers.size(); i ++) {
				if ("10.20.153.10".equals(invokers.get(i).getUrl().getHost())) {
					result.add(invokers.get(i));
				}
			}
			return result;
		} (invokers)）; // 表示立即执行方法
		2.2.0 以上版本支持 ↩︎

		路由规则扩展点：路由扩展 ↩︎

		注意：一个服务只能有一条白名单规则，否则两条规则交叉，就都被筛选掉了 ↩︎

		注意：脚本没有沙箱约束，可执行任意代码，存在后门风险 ↩︎

配置规则

	向注册中心写入动态配置覆盖规则 [1]。该功能通常由监控中心或治理中心的页面完成。

		RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
		Registry registry = registryFactory.getRegistry(URL.valueOf("zookeeper://10.20.153.10:2181"));
		registry.register(URL.valueOf("override://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&timeout=1000"));
		其中：

		override:// 表示数据采用覆盖方式，支持 override 和 absent，可扩展，必填。
		0.0.0.0 表示对所有 IP 地址生效，如果只想覆盖某个 IP 的数据，请填入具体 IP，必填。
		com.foo.BarService 表示只对指定服务生效，必填。
		category=configurators 表示该数据为动态配置类型，必填。
		dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。
		enabled=true 覆盖规则是否生效，可不填，缺省生效。
		application=foo 表示只对指定应用生效，可不填，表示对所有应用生效。
		timeout=1000 表示将满足以上条件的 timeout 参数的值覆盖为 1000。如果想覆盖其它参数，直接加在 override 的 URL 参数上。
		示例：

		禁用提供者：(通常用于临时踢除某台提供者机器，相似的，禁止消费者访问请使用路由规则)

			override://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&disbaled=true
		
		调整权重：(通常用于容量评估，缺省权重为 100)

			override://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&weight=200
		
		调整负载均衡策略：(缺省负载均衡策略为 random)

			override://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&loadbalance=leastactive
		
		服务降级：(通常用于临时屏蔽某个出错的非关键服务)

			override://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo

服务降级

	可以通过服务降级功能 [1] 临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。

	向注册中心写入动态配置覆盖规则：

	RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
	Registry registry = registryFactory.getRegistry(URL.valueOf("zookeeper://10.20.153.10:2181"));
	registry.register(URL.valueOf("override://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&mock=force:return+null"));
	其中：

	mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。
	还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。
	
优雅停机
	Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。

	原理
	
	服务提供方
	
		停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。
		然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。
	
	服务消费方
	
		停止时，不再发起新的调用请求，所有新的调用在客户端即报错。
		然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。
		
	设置方式
	
		设置优雅停机超时时间，缺省超时时间是 10 秒，如果超时则强制关闭。

		# dubbo.properties
		dubbo.service.shutdown.wait=15000
		如果 ShutdownHook 不能生效，可以自行调用，使用tomcat等容器部署的場景，建议通过扩展ContextListener等自行调用以下代码实现优雅停机：

		ProtocolConfig.destroyAll();

主机绑定

	查找顺序
	
		缺省主机 IP 查找顺序：

		通过 LocalHost.getLocalHost() 获取本机地址。
		如果是 127.* 等 loopback 地址，则扫描各网卡，获取网卡 IP。
	
	主机配置
	
		注册的地址如果获取不正确，比如需要注册公网地址，可以：

		可以在 /etc/hosts 中加入：机器名 公网 IP，比如：

		test1 205.182.23.201
		在 dubbo.xml 中加入主机地址的配置：

		<dubbo:protocol host="205.182.23.201">
		或在 dubbo.properties 中加入主机地址的配置：

		dubbo.protocol.host=205.182.23.201
		
	端口配置
	
		缺省主机端口与协议相关：

		协议	端口
		dubbo	20880
		rmi	1099
		http	80
		hessian	80
		webservice	80
		memcached	11211
		redis	6379
		可以按照下面的方式配置端口：

		在 dubbo.xml 中加入主机地址的配置：

		<dubbo:protocol name="dubbo" port="20880">
		或在 dubbo.properties 中加入主机地址的配置：

		dubbo.protocol.dubbo.port=20880

日志适配

	自 2.2.1 开始，dubbo 开始内置 log4j、slf4j、jcl、jdk 这些日志框架的适配 [^1]，也可以通过以下方式显示配置日志输出策略：

	命令行

	java -Ddubbo.application.logger=log4j


	0. 在 `dubbo.properties` 中指定

		```
	dubbo.application.logger=log4j
	在 dubbo.xml 中配置

	<dubbo:application logger="log4j" />


	[^1]: 自定义扩展可以参考[日志适配扩展](http://dubbo.apache.org/books/dubbo-dev-book/impls/logger-adapter


访问日志

	如果你想记录每一次请求信息，可开启访问日志，类似于apache的访问日志。注意：此日志量比较大，请注意磁盘容量。

	将访问日志输出到当前应用的log4j日志：

	<dubbo:protocol accesslog="true" />
	将访问日志输出到指定文件：

	<dubbo:protocol accesslog="http://10.20.160.198/wiki/display/dubbo/foo/bar.log" />

服务容器

	服务容器是一个 standalone 的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。

	服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。

	服务容器的加载内容可以扩展，内置了 spring, jetty, log4j 等加载，可通过容器扩展点进行扩展。配置配在 java 命令的 -D 参数或者 dubbo.properties 中。

	容器类型
	
		Spring Container
		自动加载 META-INF/spring 目录下的所有 Spring 配置。

		配置 spring 配置加载位置：

		dubbo.spring.config=classpath*:META-INF/spring/*.xml


		### Jetty Container

		* 启动一个内嵌 Jetty，用于汇报状态。
		* 配置：
			* `dubbo.jetty.port=8080`：配置 jetty 启动端口
			* `dubbo.jetty.directory=/foo/bar`：配置可通过 jetty 直接访问的目录，用于存放静态文件
			* `dubbo.jetty.page=log,status,system`：配置显示的页面，缺省加载所有页面


		### Log4j Container

		* 自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。
		* 配置：
			* `dubbo.log4j.file=/foo/bar.log`：配置日志文件路径
			* `dubbo.log4j.level=WARN`：配置日志级别
			* `dubbo.log4j.subdirectory=20880`：配置日志子目录，用于多进程启动，避免冲突

		## 容器启动

		缺省只加载 spring

		```sh
		java com.alibaba.dubbo.container.Main
		通过 main 函数参数传入要加载的容器

		java com.alibaba.dubbo.container.Main spring jetty log4j
		通过 JVM 启动参数传入要加载的容器

		java com.alibaba.dubbo.container.Main -Ddubbo.container=spring,jetty,log4j
		通过 classpath 下的 dubbo.properties 配置传入要加载的容器

		dubbo.container=spring,jetty,log4j

ReferenceConfig 缓存

	ReferenceConfig 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 ReferenceConfig 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。

	因此，自 2.4.0 版本开始， dubbo 提供了简单的工具类 ReferenceConfigCache用于缓存 ReferenceConfig 实例。

	使用方式如下：

	ReferenceConfig<XxxService> reference = new ReferenceConfig<XxxService>();
	reference.setInterface(XxxService.class);
	reference.setVersion("1.0.0");
	......
	ReferenceConfigCache cache = ReferenceConfigCache.getCache();
	// cache.get方法中会缓存 Reference对象，并且调用ReferenceConfig.get方法启动ReferenceConfig
	XxxService xxxService = cache.get(reference);
	// 注意！ Cache会持有ReferenceConfig，不要在外部再调用ReferenceConfig的destroy方法，导致Cache内的ReferenceConfig失效！
	// 使用xxxService对象
	xxxService.sayHello();
	消除 Cache 中的 ReferenceConfig，将销毁 ReferenceConfig 并释放对应的资源。

	ReferenceConfigCache cache = ReferenceConfigCache.getCache();
	cache.destroy(reference);
	缺省 ReferenceConfigCache 把相同服务 Group、接口、版本的 ReferenceConfig 认为是相同，缓存一份。即以服务 Group、接口、版本为缓存的 Key。

	可以修改这个策略，在 ReferenceConfigCache.getCache 时，传一个 KeyGenerator。详见 ReferenceConfigCache 类的方法。

	KeyGenerator keyGenerator = new ...
	ReferenceConfigCache cache = ReferenceConfigCache.getCache(keyGenerator );


线程池自动dump

	当业务线程池满时，我们需要知道线程都在等待哪些资源、条件，以找到系统的瓶颈点或异常点。dubbo通过Jstack自动导出线程堆栈来保留现场，方便排查问题

	默认策略:

	导出路径，user.home标识的用户主目录
	导出间隔，最短间隔允许每隔10分钟导出一次
	指定导出路径：

	# dubbo.properties
	dubbo.application.dump.directory=/tmp
	<dubbo:application ...>
		<dubbo:parameter key="dump.directory" value="/tmp" />
	</dubbo:application>

Netty4
	dubbo 2.5.6版本新增了对netty4通信模块的支持，启用方式如下

	provider端：

	<dubbo:protocol server="netty4" />
	或

	<dubbo:provider server="netty4" />
	consumer端：

	<dubbo:consumer client="netty4" />

	注意

	provider端如需不同的协议使用不同的通信层框架，请配置多个protocol分别设置
	consumer端请使用如下形式：
	<dubbo:consumer client="netty">
	  <dubbo:reference />
	</dubbo:consumer>
	<dubbo:consumer client="netty4">
	  <dubbo:reference />
	</dubbo:consumer>
	接下来我们会继续完善：

	性能测试指标及与netty3版本的性能测试对比，我们会提供一份参考数据


在Dubbo中使用高效的Java序列化（Kryo和FST）
	
	启用Kryo和FST
		使用Kryo和FST非常简单，只需要在dubbo RPC的XML配置中添加一个属性即可：

		<dubbo:protocol name="dubbo" serialization="kryo"/>
		<dubbo:protocol name="dubbo" serialization="fst"/>
		
	注册被序列化类
		要让Kryo和FST完全发挥出高性能，最好将那些需要被序列化的类注册到dubbo系统中，例如，我们可以实现如下回调接口：

		public class SerializationOptimizerImpl implements SerializationOptimizer {

			public Collection<Class> getSerializableClasses() {
				List<Class> classes = new LinkedList<Class>();
				classes.add(BidRequest.class);
				classes.add(BidResponse.class);
				classes.add(Device.class);
				classes.add(Geo.class);
				classes.add(Impression.class);
				classes.add(SeatBid.class);
				return classes;
			}
		}
		然后在XML配置中添加：

		<dubbo:protocol name="dubbo" serialization="kryo" optimizer="com.alibaba.dubbo.demo.SerializationOptimizerImpl"/>
		在注册这些类后，序列化的性能可能被大大提升，特别针对小数量的嵌套对象的时候。

		当然，在对一个类做序列化的时候，可能还级联引用到很多类，比如Java集合类。针对这种情况，我们已经自动将JDK中的常用类进行了注册，所以你不需要重复注册它们（当然你重复注册了也没有任何影响），包括：

		GregorianCalendar
		InvocationHandler
		BigDecimal
		BigInteger
		Pattern
		BitSet
		URI
		UUID
		HashMap
		ArrayList
		LinkedList
		HashSet
		TreeSet
		Hashtable
		Date
		Calendar
		ConcurrentHashMap
		SimpleDateFormat
		Vector
		BitSet
		StringBuffer
		StringBuilder
		Object
		Object[]
		String[]
		byte[]
		char[]
		int[]
		float[]
		double[]
		由于注册被序列化的类仅仅是出于性能优化的目的，所以即使你忘记注册某些类也没有关系。事实上，即使不注册任何类，Kryo和FST的性能依然普遍优于hessian和dubbo序列化。

协议
	dubbo协议
		Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。
		反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。




	