数据库的锁
	在允许一些并行操作的同时，要求保证数据库的完整性和一致性。
注意
	事务处理是
	数据库的全部工作，他们是好的事务。
	只要必须就应该推迟提交。即不是在必须前提交，而是在必须提交时提交。
	只要需要，就应该保持对数据的锁定，他们是可供使用的工具，不是避免的东西。
	在oracle中行一级锁定不包含开销
	不应该由于系统上的性能较好而将锁定扩大。
	可以获得并行处理和一致性。可以即快又准确得到，且每次都一样。
3.2.1丢失更新：
	定义：用户一检索了一行数据。
			用户二检索了第二行数据。
			用户一更改了这条数据并提交。
			用户二也更改了这个数据并提交。
			这时候，用户一以为数据是他更新后的数据，其实是用户二更新后的数据。
			
	1.悲观封锁：
		即我们认为用户在查询明细的时候就要修改数据。
		select * from user_info where id = 1 for update nowait
		使用悲观锁时，我们查询会有三个结果：
		(1)如果该行数据没有修改，那我们会获得该行数据，并加上锁。不允许其他人对该行进行更新操作。
		(2)如果另外一个用户在修改这一行数据，那我们会获得“ORA-00054”资源忙的错误。我们被阻塞，必须等待该用户完成工作
		(3)在选择数据和指出更新意图之间的时间里，如果有人已经更改了这个行，那么我们将会获得零行。
	2.乐观封锁
		update table_name set column1 = new_value1,column2 = new_value2 where column1 = old_value1 and column2 = old_value2
		如果更新了零行，说明其他人已经修改了数据。
	
3.2.2 阻塞
		定义：当一个会话访问一个被另外一个会话正在请求的资源上的锁定时，第一个会话就会被阻塞，他会被一直挂起，知道持有锁的会话放弃锁定的资源为止。
		1 被阻塞的插入
			如果两个用户插入两条主键一样是数据，其中一条被挂起，直到另一条的保存数据成功，后这一条会报主键重复的错误。
			使用序列生成主键，在多进程中也会生成唯一的主键。
		
		2.阻塞的更新和删除
			会存在丢失更新的问题。
			为了避免更新一个其他用户已经在更新的数据，使用select for update查询来锁定行，防止将数据查询出来后就没有被更新。
3.2.3 死锁
	定义：两个而用户占有别人希望持有的资源时，就会发生死锁。
	例子：A表B表各有一条数据，执行操作A表更表记录，再更新B表记录，B表更新记录B表的记录再更新A表的记录。此时就可能发生死锁。这两个会话中的一个会被选中成“牺牲者”，并使它的语句回滚。
	解决死锁的唯一语句就是回滚。
	sql window--A:
	update died_lock_A a set a.name = 'A' where a.id = 1;--语句1
	update died_lock_B b set b.name = 'A' where b.id = 1;--语句2
	sql window--B:
	update died_lock_B b set b.name = 'B' where b.id = 1;--语句3
	update died_lock_A a set a.name = 'B' where a.id = 1;--语句4
	按顺序执行语句1-3-2-4，期间都不要commit，就会出现死锁，错误信息为：等待资源时检测到死锁。
	
	若有一对父子表，即存在外键关系
		如果更新父表的主码，字表将因为没有索引而被锁定。
		如果删除了父表的行，整个字表也将被锁定。
		如果子表已经有父表的索引，那么删除或更新父表的外键时，保证子表不存在该外键的记录。
	
锁定扩大
	当发生锁定扩大情况时，系统就要降低锁定的粒度。
	
	oracle不会扩大一个锁定，但是会转换锁定。
	
	
锁定类型

	按用户和系统分可以分为自动锁和显示锁
	
		自动锁
			DML锁定
			DDL锁
			systemlocks
		
		显示锁
			用户自己显示的锁定数据库的数据。
			
	按锁级别分可以分为排他锁和共享锁
	
		排他锁：x锁
		共享锁：s锁
		
	按操作分可以分为DML锁DDL锁和SystemLocks Dml锁
	
		DML 锁用于控制并发事务中的数据操纵，保证数据的一致性和完整性。

		DML锁主要用于保护并发情况下的数据完整性。

		DML 语句能够自动地获得所需的表级锁（TM）与行级（事务）锁（TX）
		它又分为： 
		（ 1） TM 锁（表级锁） 
		（ 2） TX 锁（ 事务锁或行级锁）
		
	按操作对象分
		
		DML（数据锁）
		
		DDL（字典锁）

	在oracle中，锁定一般有下面五种类型，前三个是共有的，后两个是OPS（Oracle并行服务器）独有的。
	
		DML锁定：数据行和表的锁定，select、insert、delete、update
		
		DDL锁定：数据结构的锁定，例如create和alter、drop
		
		内部锁定和锁存器（latch）：当oracle分析一个查询，并生成优化方案时，会将告诉缓存器锁存（例如查询的时候，读取数据到缓存区，展示）。
		
		分布式锁定：这是ops使用的锁定，波阿虎不同节点上的资源相互之间的一致。由数据库实例持有。
		
		PCM(并行缓冲器管理)锁定：保护多个实例之间缓冲存储器中高速缓存的数据块的锁定。
	
	DML（数据锁）锁定
	
		TX（事务）锁定
		
			排他锁；行级独占锁。
			
		TM（DML入队）锁定
		
			这些锁定保证在更改表内容时，表的结构不会被更改。
			
			NONE：不存在锁
			
			NULL：空锁
			
			行级共享锁（RS）
			
			行级独占锁（RX）
			
			表记共享锁（S）
			
			表记独占锁（X）
			
		DML总结：
			读永远不会阻止写。但有唯一的一个例外，就是select ...for update。
			写永远不会阻塞读。当一行被修改后，Oracle通过回滚段提供给数据的一致性读。
			
	
	
	DDL（字典锁）锁定
	
		DDL是数据结构操作，修改表结构的时候，防止其它会话对表结构进行修改，也防止其他会话修改表的内容。
		实际上，在DDL操作的时候，会立即释放锁。因为会自动的隐式提交。所以DDL总是提交的，即时不成功，也会提交。失败操作会持久化，需要些一个自治事务来处理。
		
		有三种DDL锁定
		
			独占的DDL锁定：这些锁定防止其他会话获得DDL锁定或TM锁定。所以DDL操作期间，只能查询，不能修改。
				
			共享DDL锁定：引用对象的结构不能被其他会话修改，但是数据可以被修改。	
				
			（看不懂！）可打破的分析锁定：他允许对象，如共享池中高速缓存的查询方案，在一些其他对象上注册它信任。
			
			
		多数的DDL使用独占的DDL锁定。
		
		一些DDL操作也不会产生DDL独占锁。例：create index t_id on t(x) online;
		
		使用DDL共享锁：例如 当创建存储的、经过编译的对象，如过程和视图时，即可以改值，不能改结构！
			
		（看不懂！）使用可打破分析锁定：当会话解析一条语句时，针对每一个由该条语句引用的对象施加一个分析锁定。
	
	锁存器和内部锁定（入队）
		
		定义：锁存器和排队是轻量的序列化设备，用于协调多用户对共享的数据结构、对象和文件的访问。
		
		锁存器是在极短时间内，用于修改例如内存里数据结构的时间内保持的锁定。他们用来保护某些内存结构。例如：数据库块缓冲存储器中的高速缓存器。
		
		锁存器的分配是随机的
		
		请求锁存器的时候，如果此时锁存器不可用，正在请求的会话会休眠一段时间，然后重新操作。所以请求先后和获得锁存器的机会没有直接关系。
		
		先不断重复执行sbin（选择），重复请求，sbin达到一定次数，然后就睡眠一定时间，然后继续重复请求，睡眠时间随着重读次数的增多而增多。如果当前进程已经占用了其他的锁存器，那么在请求这个锁存器的时候的睡眠时间就会设置的比较短。
		
		入队是另一个更加复杂的串行化设备。和锁存器的区别是，他们允许请求者排队等待资源。即请求者会被阻塞，知道得到入队资源位置。速度肯定没锁存器快。
	
	手动封锁和用户自定义锁定
	
		两种途径
			借助sql手动封锁
			借助DBMS_LOCK包创建锁定
			
		手动封锁
			
			select ...... for update
			
			lock table :
				这个锁定粗糙，很少用。只是锁定表，不锁定表的行。
				所以一般使用lock table [table_name] in exclusice mode。
			
		创建自己的锁定
		
			用dbms_lock包来对外部资源的访问加锁
			
并行控制
	
	定义：并行控制是数据库提供的函数集，起目的是允许许多用户同时访问和修改数据。
	
	并行控制胜过锁定
	
	多版本控制器
	
	
	
其他总结：
	select * from table_name for update;
	select * from  table_name for update nowait;
	select * from  table_name for update wait second;这三个语句的区别
	事务A执行select * from table_name where id = 1 for update时，当id=1的记录被其他事务B占有时，事务A会被挂起，直到事务B执行完毕提交后，事务A才会继续执行。
	事务A执行select * from  table_name for update nowait;时，当id=1的记录被其他事务B占有时，事务A会立即报错“资源正忙......”。
	事务A执行select * from  table_name for update wait second;时，
	当id=1的记录被其他事务B占有时，事务A会等待second秒，如果过了second秒，B事务还是占有着id=1的记录，那么会报错“资源正忙......”，如果senond秒后B事务不再占有id=1的记录，那么事务A会执行。
	
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	