IO和NIO
	面向流面向缓存
		IO是面向流(stream)的，会逐个字符读取，并且不能改变字符的位置。
		NIO的面向缓冲区(buffer)的，会先把字符读取到缓存区，然后可以再缓存区里面对现有字符进行操作。
	阻塞和非阻塞
		IO：java的各种io流是阻塞的，即读取同一个文件时，需要等待前面的流读写完后，自己才能开始读写，
		NIO:当NIO流读取文件时，可读取的信息已经读取完毕，此时Nio流不会保持对该文件的阻塞，其他流可以操作该文件流，至少该流又有可读取数据时，nio流会继续读取。
		
总结

NIO允许你用一个单独的线程或几个线程管理很多个channels（网络的或者文件的），代价是程序的处理和处理IO相比更加复杂

如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些，相似的，如果你需要保持很多个到其他电脑的连接，例如P2P网络，用一个单独的线程来管理所有出口连接是比较合适的

如果你只有少量的连接但是每个连接都占有很高的带宽，同时发送很多数据，传统的IO会更适合

selector
	nio中，所有的请求都不会阻塞，是因为所有的请求都会注册在selector，由他来管理所有的io请求。
	
NIO的本质是延迟IO操作到真正发生IO的时候,而不是以前的只要IO流打开了就一直等待IO操作。

读《Java NIO》笔记

	IO缓冲区操作简图：
	用户空间               内核空间              
	缓冲区 <-----red()----- 缓冲区 <-----DMA----- 磁盘控制器 <-----硬件----- 硬盘
	进程
	
	缓存
		缓存区的属性
			容量（Capacity）缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。
			上界（Limit）缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。
			位置（Position）下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。
			标记（Mark）一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position =mark。标记在设定前是未定义的( undefined) 。
		这四个属性之间总是遵循以下关系：
		0 <= mark <= position <= limit <= capacity
		
		所有的缓存区都可读，但是并非都可写，通过isReadOnly()来定义是否可写。
		
		存取
			通过get和put方法返回或修改对应索引或下一个索引的值。
			
		填充
			
		翻转
			fip（）函数将一个能够继续添加数据元素的填充状态的缓冲区翻转成一个准备读出元素的释放状态。在翻转之后，
			Rewind()函数与 flip()相似，但不影响上界属性。它只是将位置值设回 0。您可以使用 rewind()后退，重读已经被翻转的缓冲区中的数据。
			如果将缓冲区翻转两次，缓冲区上位置和上界都为 0。
		
		释放
			缓冲区并不是多线程安全的。如果您想以多线程同时存取特定的缓冲区，您需要在存取缓冲区之前进行同步（例如对缓冲区对象进行跟踪）。
		
		压缩
			 compact()函数
			 
		标记
			 mark( )函数
			 
		比较
			compareTo( )
			equals( )
			
			两个缓冲区被认为相等的充要条件是：
				  两个对象类型相同。包含不同数据类型的 buffer 永远不会相等，而且 buffer绝不会等于非 buffer 对象。
  				两个对象都剩余同样数量的元素。Buffer 的容量不需要相同，而且缓冲区中剩余数据的索引也不必相同。但每个缓冲区中剩余元素的数目（从位置到上界）必须相同。
					在每个缓冲区中应被 Get()函数返回的剩余数据元素序列必须一致。
					
	创建缓存类
	
		java中有七种主要的缓存类：MappedByteBuffer，IntBuffer，DoubleBuffer，ShortBuffer，LongBuffer，FloatBuffer，和 ByteBuffer。
		
		两种创建方式：
		
			1.
				CharBuffer charBuffer = CharBuffer.allocate(100);即分配一个容量为100个char变量的charbuffer
		
			2.
				char [] myArray = new char [100];
				CharBuffer charbuffer = CharBuffer.wrap (myArray);
		
		
	复制缓存区
		
		
	只有字节缓存区有资格参与IO操作	
		
		
	直接缓存区
		定义：直接缓冲区被用于与通道和固有 I/O 例程交互。它们通过使用固有代码来告知操作系统直接释放或填充内存区域，对用于通道直接或原始存取的内存区域中的字节元素的存储尽了最大的努力。
		
		直接字节缓冲区通常是 I/O 操作最好的选择，但可能比创建非直接缓冲区要花费更高的成本
		
		因为非直接缓存区写入时，可能隐含 创建临时直接缓存对象->将非直接缓冲区的内容赋值到临时缓存中->使用临时缓冲区执行低层次 I/O 操作->临时缓冲区对象离开作用域，并最终成为被回收的无用数据。
	
通道（Channel）
	
	定义：Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。
		
	通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的 I/O 服务。缓冲区则是通道内部用来发送和接收数据的端点。	
		
	InterruptibleChannel：是一个标记接口，当被通道使用时可以标示该通道是可以中断的	
		
	通道只能在字节缓冲区上操作。

	通道分为文件（file）通道和套接字（socket）通道
		
	FileChannel 对象却只能通过在一个打开的 RandomAccessFile、FileInputStream 或 FileOutputStream对象上调用 getChannel( )方法来获取。	
	例：RandomAccessFile raf = new RandomAccessFile ("somefile", "r");
	    FileChannel fc = raf.getChannel( );
		
	通道可以是单向（unidirectional）或者双向的（bidirectional）。	
		
		
	通道可以以阻塞（blocking）或非阻塞（nonblocking）模式运行。	非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。
	只有面向流的（stream-oriented）的通道，如 sockets 和 pipes 才能使用非阻塞模式。
		
	与缓冲区不同，通道不能被重复使用。	
		
	请不要将在 Channels 上休眠的中断线程同在 Selectors 上休眠的中断线程混淆。前者会关闭通道，而后者则不会。	
		
	仅仅因为休眠在其上的线程被中断就关闭通道	
		
	可中断的通道也是可以异步关闭的。	
	当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个 AsynchronousCloseException 异常。	
	
	gather：对于一个 write 操作而言，数据是从几个缓冲区按顺序抽取（称为 gather）并沿着通道发送的。
	
	
	scatter：对于 read 操作而言，从通道读取的数据会按顺序被散布（称为 scatter）到多个缓冲区，将每个缓冲区填满直至通道中的数据或者缓冲区的最大空间被消耗完。
	
	文件通道总是阻塞式的，因此不能被置于非阻塞模式。
	
	对于文件 I/O，最强大之处在于异步 I/O（asynchronous I/O），它允许一个进程可以从操作系统请求一个或多个 I/O 操作而不必等待这些操作的完成。
	
	
选择器

	选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		