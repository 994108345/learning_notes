普及知识；c语言的所有对象多需要自己创建，C++引入了构造器这个概念，java也采用了这个构造器。
构造器名字和类名一样就是为了防止和该类其他方法名字出现同样的方法名。
基本类型的重载会格外注意，因为基本类型能从一个“较小”的类型自动提升至一个“较大”的类型。char型略有不同，如果无法找到char参数方法，就会把char直接提升至int型，且会将char的字符转换成ascll值（就算是数字的字符也会转！）。
如果接受较小的基本类型作为参数，如果传入的实际参数较大，就要通过类型转换来执行窄化转换。不然编译器是会报错的！
根据方法的返回值区分重载是不明智的，必须以参数列表为准。
this关键字
	该关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用
	只有放需要明确指出当前对象的引用时，才需要使用this关键字
	如果你在一个构造函数里想调用其他构造函数，要通过this(),且必须放在构造函数的第一行。
	public class OverLoad {
		public OverLoad() {
			this(1);
			int c = 12;

		}
		public OverLoad(int a) {
			System.out.println("呼呼");
		}
	}

static
	static内部不能调用用非静态方法。但是可以在非静态方法里调用静态方法。且可以在没有任何对象的前提下，仅通过类本身调用static方法。

清理
	垃圾回收期只知道释放那些由new分配的内存，多疑对于一些不是new出来的对象的特殊内存，java运行我们定义一个finalize()方法，它的工作原理是一旦垃圾回收期准备好释放对象占用的存储空间，将首先调用起finalize()方法，并且在下一次垃圾回收动作发生时，，才会真正收回对象占用的内存。
	注意：
	.对象可能不被垃圾回收。
	.垃圾回收不等于“析构”
	.垃圾回收至于内存有关

	finalize()的用途何在
		垃圾回收器是唯一原因是为了收回程序不再使用的内存。
		finalize()方法是清理那些通过某种创建对象方式以外的方式为对象分配了存储空间。但是jva中一切皆对象，这么会碰到这种特殊情况呢。一般是java去调用非java代码的方法的时候，这个时候产生的对象的存储空间就不是通过new产生的。
		所以finalize并不是普通清理工作的合适场所。
		java的垃圾回收器并不能代替析构函数，当jvm并未面临内存耗尽的情况，它是不会浪费时间去执行垃圾回收以回复内存的。
		System.gc()就是用于强制进行终结动作，即进行垃圾回收,即调用finalize()方法。
例子：
	public class Book {
		boolean checkedOut = false;
		Book(boolean checkOut){
			checkedOut = checkOut;
		}
		void  checkIn(){
			checkedOut = false;
		}
		protected void finalize(){
			if(checkedOut){
				System.out.println("Error checked out");
			}
		}

		public static void main(String[] args) {
			Book novel = new Book(true);
			novel.checkIn();
			new Book(true);
			System.gc();
		}
	}
	垃圾回收器如何工作
		java 的对象都存在堆上（基本类型除外）
		垃圾回收器对于提供对象创建的速度，有明显的效果
		java 的堆分配空间就像一个传送带，每分配一个新对象，它就往前移动一格。即java 的“堆指针只是简单的移动到尚未分配”的区域。事实上，这样会造成频繁的页面调度，造成消耗更难多的性能。解决这个问题就是垃圾回收器的介入。垃圾回收器工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传动带的开始出，也就避免了页面错误。通过垃圾回收器对对象的重排列，实现了一种高速的、有无限空间可供分配的堆模型。
		垃圾回收机制
			.引用计数：简单但速度很慢的垃圾回收技术。
				当有引用连接至对象时，计数加1，当引用离开作用域或被置为null时，计数减1.当检测到计数为0时，就会释放对象的内存。但是似乎未被任何一种java虚拟机实现。
			.停止-复制：
				先暂停程序的运行。然后将所有存活的的对象从这个堆复制到那个堆，没被复制的就都是垃圾。当被复制到新堆时，会重新紧凑排序，直接就分配了新空间。这种形式的缺陷就是需要来年各个堆。维护需要两倍空间，所以某些java虚拟机的处理方式是从对总分配几块较大的内存，复制发生在大块内存之间。
			.标记-清扫
				当没有垃圾的时候，进行停止-复制就很浪费内存，所以为了避免这种情况，一些虚拟机会自行检查。要是没有垃圾就会转换到标记-清扫状态。
				遍历所有的引用，标记所有存活的对象，这个过程不回收任何对象，所有标记工作完成后，清理开始。
成员初始化：
	类的局部变量没有初始化会报错，但是类的成员变量没有初始化会给默认值，例如整型默认值0.字符串默认值null，对象默认值也是null。
	类中的全局变量会在类中所有方法执行前得到实例化。
	static关键字不能应用于局部变量，因此它只能作用于域。
	静态初始化只在class对象首次加载的时候进行一次。
	final修饰的全局变量如果没有给初值，则必须在构造方法中基于初值！！！





