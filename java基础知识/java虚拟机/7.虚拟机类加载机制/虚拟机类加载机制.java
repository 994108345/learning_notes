虚拟机类加载机制
7.1 概述
	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。
	在java语言里面，类型的加载和连接过程都是在程序运行期间完成的，增加性能开销，但是能增加灵活性。
	java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
7.2 类加载的时机
	类加载的生命周期：加载、验证、准备、解析、初始化、使用、卸载
	其中验证、准备和解析三个部分统称为连接阶段。
	加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。
	解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定，即动态绑定！
	这些阶段通常都是互相交叉地混合式进行的。
	什么时候开始加载，没有强制约束，由虚拟机自己把握。但是初始化阶段是有四个规定的！
	1 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。场景：new对象，读取静态字段时
	2 使用java.lang.reflect的方法进行反射调用的时候。如果类没有初始化，则需要先触发初始化。
	3 初始化一个类。发现父类还没有进行初始化，则需要先初始化父类
	4 虚拟机启动时，用户需要制定一个要执行的主类，包含main方法的类，虚拟机会先初始化这个类。
	这四个场景中的行为称为对一个类的主动引用，除此之外所有引用类的方式，都不会触发初始化，称为被动引用。
举例子说明被动引用
	1 通过子类引用父类的静态字段,不会导致子类初始化
public class SuperClass {
   static {
        System.out.println("SuperClass init");
    }
    public static int value = 123;
}
public class SubClass extends  SuperClass {
    static{
        System.out.println("SubClass init");
    }
}
public class NotInitialization {
    public static void main(String[] args){
        System.out.println(SubClass.value);
    }
}

输出结果：
SuperClass init
123

	对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化。

	2 通过数组定义来引用类，不会触发此类的初始化。
public class SuperClass {
   static {
        System.out.println("SuperClass init");
    }
    public static int value = 123;
}
public class SubClass extends  SuperClass {
    static{
        System.out.println("SubClass init");
    }
}
public class NotInitialization {
    public static void main(String[] args){
        SuperClass[] sca = new SuperClass[10];
    }
}
输出结果为：   

	由上可知，定义数组时，并没有初始化任何对象。

	3 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
public class ConstClass {
    static{
        System.out.println("ConstClass init!");
    }
    public static final String HELLOWORLD = "hello world";
}
public class NotInitialization {
    public static void main(String[] args){
        System.out.println(ConstClass.HELLOWORLD);
    }
}
输出结果：
hello world
	由上可知，因为在编译阶段常量就已经存在了常量池中，所以访问HELLOWORLD时，引用都是对常量池的引用，而不是对类ConstClass的引用。

	当一个类在初始化的时候，要求其父类全部都已经初始化过，但是接口在初始化时，并不要求其父类接口全部都完成初始化，只有在真正引用父类的接口的时候（如引用接口中定义的常量），才会初始化。
7.3 类加载的过程
	类加载的过程就是加载、验证、准备、解析和初始化

7.3.1 加载
	加载阶段，虚拟机需要完成三件事情。
	1 通过一个类的全限定名来获取定义类的二进制字节流。
	2 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
	3 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。
	虚拟机规范对这三点要求实际并不具体，所以虚拟机的实现和具体应用相当灵活。
	加载阶段与连接阶段的部分内容是交叉进行的。但是总的开始时间仍保持先后顺序。

7.3.2 验证
	验证是连接阶段的第一步。
	这一阶段的目的就是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
	大致都包含四个阶段的校验过程：1.文件格式验证（例版本号）。2.元数据验证（例：是否有父类）。3.字节码验证（例跳转指令不会跳转到方法体意外的字节码指令上）。4.符号引用验证（通过字符串描述的全限定名是否能找到对应的类）。
7.3.3 准备
	准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。
	注意：这时候被分配的是类变量，即静态变量，不包括实例变量，实例变量是将在对象实例化的时候分配在java堆内存中。
	而初始值就是零值，例： public static int a = 123； a的零值是0，不是123,123是实例化的时候才会给赋值。
7.3.4 解析
	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
	符号引用：
		以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。
	直接引用：
		直接引用可以说是直接指向目标的指针、相对偏移量或是是一个能间接定位到目标的句柄。
	解析动作主要正对类、接口、字段、类方法
7.3.5 初始化
	前面的步骤，都是由虚拟机主导和空值，到了初始化阶段，才真正执行java代码。
	初始化阶段就是执行类构造器<clinit>（）方法的过程。
	<clinit>()方法
		1 由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生。
		2 虚拟机保证子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕
		3 父类定义的静态语句块要优先于子类的变量赋值操作。
		4 <clinit>()方法对于类或接口来说，并不是必须的。
		5 接口中不能使用静态语句块，单仍然可以有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。
		6 虚拟机会保证一个类的<clinit>方法在多线程环境中被正确的加锁和同步。
7.4 类加载器
	通过一个类的全限定名来获取描述此类的二进制字节流，这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定怎么获取所需要的类，实现这个动作的代码模块被称为"类加载器"。

7.4.1 类与类加载器
	类加载器只用于实现类的加载动作。
	比较两个类是否相等，只有在两个类都是同一个类加载器加载的前提下才有意义，否则，即使这两个类是来源于同一个Class文件，只要类加载器不同，那两个类就不相等。
7.4.2 双亲委派模型
	在java虚拟机的角度来说，只有两种不同的类加载器：一种是启动类加载器，是虚拟机自身一部分。另一种是其他的类加载器，由java语言实现。
	从java开发人员的角度来看，可以大致分为三种
		启动类加载器：将类库加载到虚拟机内存中，不能被java程序直接引用。
		扩展类加载器：加载系统变量指定的所有类库，开发者可以直接使用扩展类加载器
		应用程序类加载器：加载用户类路径上所指定的类库。开发者可以直接使用。
	双亲委派模型主要是确保java类加载的顺序，确保一些工具类和基本类先加载。
	双亲委派，即所有的类加载都会询问父类是否可以加载该类。这么做是为了保证java程序的稳定运作，因为如果我们自己也写了一个object类，java自带一个object类，如果不委派父类先加载，那么我们自己直接加载，就引用了我们的自己写的类，没有引用父类的类，所以为了保证jvm和java写的类优先加载，并不被我们影响，所以用委托双亲先加载。











