java中浮点型包括单精度Float（32位）和双精度Double（64位）。

	定点数：
		定义：即确定小数点前有几位和小数点后有几位，例如99.00，确定了精度为4，且小数点前有两位，小数点后有两位，Sql数据库中的number就是这种类型。
		缺点：不利于表达特别大的数和特别小的数。
		
	浮点数：
		定义：即使用科学计数法来表达实数，即用一个尾数（Mantissa ），一个基数（Base），一个指数（Exponent）以及一个表示正负的符号来表达实数。
			例如123.45 用十进制科学计数法可以表达为 1.2345 × 10^2 ，其中 1.2345 为尾数，10 为基数，2 为指数。尾数也叫做有效数字。
			
	在 IEEE 标准中，浮点数是将特定长度的连续字节的所有二进制位分割为特定宽度的符号域，指数域和尾数域三个域，
	
	Float
	符号位S，在第31位
	指数位(阶码)P：第30到第23，即8位，
	尾数M（有效数）：第22到0.即23位，
	偏移量：127
	表示公式：(-1)^s * 2(P-127)*1.M
	
	Double
	符号位S，在第63位
	指数位(阶码)P：第62到第52，即11位，
	尾数M（有效数）：第51到0.即52位，
	偏移量：1023
	表示公式：(-1)^s * 2(P-1023)*1.M
	
	IEEE754标准规定一个实数V可以用:　　V＝(－1)^s * M * 2^E的形式表示，说明如下：
	　　(1)符号s(sign)决定实数是正数(s＝0)还是负数(s＝1)，对数值0的符号位特殊处理。
	　　(2)有效数字M是二进制小数，M的取值范围在1≤M＜2或0≤M＜1。
	　　(3)指数E（exponent）是2的幂，它的作用是对浮点数加权。

	为了强制定义一些特殊值，IEEE标准通过指数将表示空间划分成了三大块：
	　　【1】最小值指数（所有位全置0）用于定义0和弱规范数
	　　【2】最大指数（所有位全值1）用于定义±∞和NaN（Not a Number）
	　　【3】其他指数用于表示常规的数。
	
	通常情况，IEEE标准写法，尾数的1省略，所以1.001001记做Fraction= 0.001001，因为标准写法，前面的1总是省略Fraction = 尾数 - 1 （IEEE规定小数点左侧的 1 是隐藏的,也叫隐藏位）。
	
	浮点数的表示有一定的范围，超出范围时会产生溢出（Flow），一般称大于绝对值最大的数据为上溢（Overflow），小于绝对值最小的数据为下溢（Underflow）。
	
程序中浮点数计算为什么不精确
	因为计算机是采用二进制计算的，二进制的小数只能表达为 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n），所以有很多十进制小数，二进制小数根本无法表达准确。	
	
	
	NaN:（not a number）无法和int类型进行比较
		1.0/0.0:非0数除以0时
		Math.sqrt(-100):求负数的平方根
	Infinity:（无限大）大于所有的整型值
		0.0/0.0:0除以0的时候，得到无限大。
		
用BigDecimal解决浮点数精度的问题
	BigDecimal使用十进制+小数点位置(scale)来表示小数
	100.001 = 100001* 0.1^3，就是这么表示的
	
BigInteger 可以处理任何精度的运算
	如果Long都计算溢出了，就要考虑使用BigInteger了
	实现方式是数组！数组里存的是byte
	例如：[2, 1]，也就是[00000010B, 00000001B]，就是表示二进制的00000010 00000001B这个数，也就是513了。 
	