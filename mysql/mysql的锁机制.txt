mysql锁和事务
	Linux下安装的MySQL的默认存储引擎为MyISAM，但由于不支持事物外键等特性，一般会选用InnoDB作为存储引擎。
	window下安装的MYsql默认存储引擎是InnoDB。
	
	设计目标：
		InnoDB设计目标是处理大容量的数据，
		而MyISAM追求的是性能。 性能方法，最能体现差别的就是锁，因为MyIsam只支持表锁，InnoDB支持行锁和表锁，表锁的性能消耗比行锁小。
		
		表锁和行锁的区别：
			表锁：不会出现死锁，发生锁冲突几率高，并发低。
			行锁：会出现死锁，发生锁冲突几率低，并发高。
	
	innoDB和MyIsam的最大不同：
	1 InnoDB支持事务  
	2：InnoDB采用行级锁，MyIsam只支持表锁。
	
	很多时候加锁就是为了让事务执行正确，下面来简单说一下事务
	
	定义：事务是一组不可被分割执行的SQL语句集合，如果有必要，可以撤销。
	
	事务及其ACID属性
		
		原子性（Atomicity）：要么都不执行，要么都执行。事务的所有操作在数据库中要么全部正确反映，要么全部不反映。
		
		一致性（Consistent）一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。
		
		隔离性（Isolation）：InnoDB支持四种隔离级别
			
			读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用）
			
			读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。
			
			可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。
				
			串行化：事务串行执行。避免了以上所有问题。
			
			mysql默认隔离级别是可重复读。
			
			可重复读用到了MVCC的全称是“多版本并发控制”技术：
			
				mvcc就是给每一行增加两个隐藏字段，存的是事务版本号，一个是删除版本号，一个是创建版本号。
				
				每开启一个事务，事务的版本号就会递增。
				
				增删改查
					SELECT：符合以下两个条件的记录才能被事务查询出来！
						删除版本号大于当前事务版本号。就是说删除操作是在当前事务启动之后做的。 
						创建版本号小于或等于当前版本号。就是说记录创建是在事务中（等于的情况）或者事务启动之前。
					
					INSERT
						将当前事务的版本号保存至行的创建版本号
					
					UPDATE
						原纪录不删除，新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
					
					DELETE
						将当前事务的版本号保存至行的删除版本号
						
				mvcc只是保证当前事务内处理的数据为同一个版本，不会被其他事务的操作所影响。
				
				快照读和当前读
					
					快照读：读取的是快照版本，也就是历史版本。快照读就是根据mvcc版本控制实现的。
					
					当前读：读取的是最新版本。通过记录锁和间隙锁实现的。
				
					普通的select就是快照读。
					而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。
			
		
		持久性（Durable）：事务一旦执行成功， 即使此时机子挂了，数据库还是会被这个事务。原因是因为事务操作在提交前会写入本地undo、redo日志文件，就算挂了，重启数据库后，数据库还是会根据本地文件去更新数据库。
	
	获取InnoDB行锁争用情况
		
		show status like 'innodb_row_lock%'//查看数据库的行锁情况
		
	InnoDB的行锁模式及加锁方法
	
		InnoDB实现了两种类型的行锁
			
			共享锁(S):允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。一个记录最多只能存在两个共享苏，第三个共享锁会被阻塞！其他事务可以读值，不能修改值！
			
			排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。//其他事务可以读取值，但是不能修改值
			
			注意：
				当sql操作匹配不到数据时，是不会加锁的。
				当A事务给表加了共享锁/排他锁时，注意！A事务不能提交！，此时B事务修改表结构信息会进入阻塞状态，但是在A事务中修改表结构是可以的，并且A事务发布的共享锁、排他锁解掉！
				同一个事务内可以随时切换锁！！！

		InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁！
		
			意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。		
				
			意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。
						X		       S 			    IS  			  IX
			X		  冲突			  冲突				冲突			冲突
			S		  冲突 			  兼容			    兼容			冲突
			IX		  冲突            冲突              兼容            兼容
			IS    	  冲突			  兼容				兼容			兼容					
			
			上图可以理解成连个事务，一个事务A在拥有意向排他锁时，另外一个事务B想加排他锁，此时，事务A加完意向排他锁后，肯定是要加排他锁，而此时B也要加，就有两个排他锁，排他锁只能存在一个，所以互斥才能保证锁的正确执行。
			
			意向锁之间是互相兼容的，真正需要判断兼容不兼容的地方是给行加锁的时候。
			
			意向锁是 InnoDB 自动加的，不需用户干预
			
			对于 UPDATE、DELETE 和 INSERT 语句，InnoDB会自动给涉及数据集加排他锁（X)；
			
			对于普通 SELECT 语句，InnoDB 不会加任何锁
			
			事务可以通过以下语句显示给记录集加共享锁或排他锁。
			
				共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
 				排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

			对于锁定行记录后需要进行更新操作的应用，应该使用 SELECT... FOR UPDATE 方式获得排他锁。
			
	间隙锁
		
		当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。
		
			例如：有emp表，有数据empid 1.....100,101 ；Select * from emp where empid > 100 for update;
			
			innoDB会对101的数据加锁，并且不存在的>101的数据加间隙锁。
			
			InnoDB 使用间隙锁的目的，一方面是为了防止幻读
		
		InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁！
		
			还是上面的例子；不存在数据102，我们使用select *from emp where empid = 102,因为不存在该数据，所以会加间隙锁，当其会话插入大于102的数据时，就会等待。
			例：insert into emp (empid)valuse(103) 就会阻塞等待
			
	回复和复制的需要，对InnoDB锁机智的影响
		
	
	什么时候使用表锁
		
		1：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。
		
		2：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。
	
	在InnoDB下，使用表锁要注意两点
	
		1：使用 LOCK TABLES 虽然可以给 InnoDB 加表级锁，但必须说明的是，表锁不是由 InnoDB存储引擎层管理的，而是由其上一层──MySQL Server 负责的，仅当 autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB 层才能知道 MySQL 加的表锁，MySQL Server也才能感知 InnoDB 加的行锁，这种情况下，InnoDB 才能自动识别涉及表级锁的死锁；否则，InnoDB 将无法自动检测并处理这种死锁。有关死锁，下一小节还会继续讨论。
		
		2：在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则MySQL 不会给表加锁，因为mysql默认自动提交！；事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES会隐含地提交事务；COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用UNLOCK TABLES 释放表锁
		
	查看锁表的情况
		注意：必须是有锁冲突了，才会显示。如果只是一个事务A锁了某表，其他事务没有来请求这个锁的话，就查不到东西了。
		show status like 'Table%';
			Table_locks_immediate  指的是能够立即获得表级锁的次数
			Table_locks_waited  指的是不能立即获取表级锁而需要等待的次数
		
		查看锁的表
			show OPEN TABLES where In_use > 0
		
		查看正在锁的事务
			SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 
		
		
		show status like '%lock%'
		
		查询进程：可以通过然后 kill    id删除进程
			show processlist 
		
		参考微博：https://www.cnblogs.com/dongqingswt/p/3460440.html
		