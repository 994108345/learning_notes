spring知识点：
	Spring有九大模块
	spring容器
	spring Context
	spring AOP
	Spring IOC
	spring Web
	Spring Orm
	Spring Mvc
	spring Dao
	其中最突出的就是Aop和IOC
	Aop：面向方面编程
	我们在日常写代码的时候，比如日志记录，是一个很多地方都会用到的代码，但是这个代码缺和我们的业务逻辑无关，我们不想为了记录日志在很多地方都创建日志对象，去记录日志信息，会造成很多重复代码。这也是面向对象编程的弊端，针对这个弊端，spring设计了面向方面的编程，所有的代码中不需要创建日志信息，全部使用spring创建的一个日志对象，经过动态代理的JDK动态代理和CGLIB动态代理，将运行的代码增强，让其调用日志方法。
	JDK动态代理要求类不许有接口：实现InvocationHandler（调用处理器） 类，重写invoke方法。
	CGLIB动态代理要求类必须没有接口，且不能是final类：实现MethodInterceptor（方法拦截器）类，重写intercept方法。为我们的实现类提供了一个子类，并在子类中采用拦截技术拦截父类的调用，从而达到代理作用。

	IOC：控制反转，另外一种说法叫做DI依赖注入
	原理：我们日常使用对象时，都是我们手动去创建对象，使用spring框架后，不需要我们去创建对象，而是由spring容器去创建对象，我们只需要再配置文件里配置要生成对象的信息即可，spring会根据我们配置的类的全限定类名信息通过反射去调用。同时spring默认保持着单例创建。通过这种方式，达到对象之间的解耦。
	缺点：反射创建对象相对直接创建对象，还是比较慢的。
	Ioc的一个重点就是DI依赖注入：即A对象再运行的时候需要B对象，但是B对象不需要A创建，且B也不需要知道A什么时候被创建。A创建是Spring来实现的，而且是在系统运行的时候，Speing会在适当的时候创建一个A对象。而实现DI就是反射技术。

Mybatis实现的原理：
	mybatis最主要的功能分为两种:
	1:封装JDBC操作
	2：利用反射打通java类与sql语句之间的相互转换。
	核心设计目的就是为了方便的执行sql语句并且方便的获取sql运行结果。

Dubbo：Dubbo图
	是开源的分布式框架。
	Consumer：消费者
	Provider：提供者
	Monitor:监控“监控统计Rpc（远程调用）状况
	Registry:注册器：是全局配置信息管理模块
	Container:容器
	注册中心：dubbo已经可以支持四种注册中心，zookeeper、redis、multicast、dubbo简易注册中心。
	zookeeper：dubbo推荐使用的。zookeeper挂掉一半的机器集群就不可用了。
	zookeeper的用来注册服务和负载均衡。决定哪一个服务由哪一个机器来提供必需让调用者知道。简单就是ip地址和服务名称的关系。zookeeper通过心跳机制可以检测挂掉的机器，并把他从ip和服务的列表中删除，dubbo只是个框架，zookeeper就是框架上的货物。zookeeper群可以有资源同步的功能。

MongoDB:
	为什么使用mongoDB:
	1.快速，拥有适量内存的MongoDB的性能是非常迅速的。将热数据存储在物理内存中，所以读写特别快。
	2.高扩展性：高可用和集群框架拥有十分高的扩展性。
	3.自身的Failover机制：当主库遇到问题时，无法继续提供服务时，副本集将会选举出一个新的主库来继续提供服务。
	4：Json的存储格式：Json的存储格式，十份适合文档格式的存储和查询
	
	缺点：没有事务机制，要实现事务，需要通过一个额外的表，从逻辑上自行实现事务。
	
	MongoDB数据存内存，当内存不够时，只会将热点数据存内存，其他数据存磁盘。
	
	mongoDB如何实现事务的
		1.原子性：mongoDB在更新100条数据时，更新到51条的时候服务器挂了，此时，前五十条已经更新完毕的数据不会回滚，只是51条的更新失败，即51条还是原来的数据
		如何解决：将mongoDB需要更新的数据同步到另外一张表上，再执行操作。
		2.一致性：
		分为强一致性和弱一致性
		强一致性：要求集群中所有的服务器状态同步保持一致。
		弱一致性：可以允许短暂的数据不一致，单最终会保持一致。
		mongoDB是分布式的，会有多个节点，如何保证多个节点的数据是一致的就很困难了。
			CAP理论
				为什么我们会考虑削弱数据的一致性呢？主要是因为CAP理论：
				一致性（C）：在分布式系统中所有的数据备份，在同一时刻是否同样的？
				可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求？
				分区容忍性（P）：集群中的某些节点在无法联系后，集群整体是否还能继续进行服务？
				CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。
				由于当前网络硬件肯定会出现延迟丢包等问题，所以分区容忍是我们必须实现的。所以我们必须选择实现一致性或可用性，没有nosql系统能同时保证这三点。
				一致性的实现就是所有的写操作在所有数据节点上都执行成功后才返回成功。
				可用性的实现就意味着在节点响应请求时，不用完全考虑这个集群中的数据是否一致。这就要求不保证所有结点都要返回成功才算成功。
				
		3.隔离性的支持
			READ-UNCOMMITTED（读尚未提交的数据）
			READ-COMMITTED（读已提交的数据）
			REPEATABLE-READ（可重复读）
			SERIALIZABLE（串行化）
		4.持久化的支持
			通过日志信息恢复数据
		
		具体方案
		1：字段同步
			给所有的记录加上一个字段记录更新时间：入updateDate，在更新的时候为updatDate赋值，更新完后再移除这个字段。如果中间出错，直接判断updateDate字段就知道哪些数据没有更新，这样就实现事务了。
		2：作业队列
			将操作信息记录到一个队列中，只有全部更新成功了才会更新操作队列的状态
			
		3.二阶提交
			首先创建一个事务集合，在集合里插入一个事务信息{source: "A", destination: "B", value: 100, state: "initial"}
			在所有需要更新的集合里插入一个字段transaction，用来记录事务id。此时，值为空
			在修改记录前，将事务记录的状态由initial设置为pending
			将事务id更新到需要更新的记录中
			此时将事务记录状态设置为commit
			然后在字段中删除更新记录中transaction总的值
			将事务记录的状态设置为done
			由上个例子可以总结出步骤
				准备工作：需要更新的记录必须有一个字段，存储事务信息。
				第一步：创建一个事务集合，插入一个事务文档。初始状态为initial。
				第二步：事务状态由initial切换到pending。
				第三步：执行更新操作，同时修改被更新记录中的事务字段为事务文档的id，以表明，被事务操作了。
				第四步：事务状态由pending转换成commit
				第五步：将被更新记录中所有的事务字段改成null。
				第六步：事务状态由comit编程done。
			事务失败后怎么恢复：
				如果在第一步之后到第三步完成前失败了，回到第二步
				如果在第三步后到第五步完成前失败了，回到第四步
				回滚（在事务发生错误）和撤销（事务已经完成）：
					事务状态改成cancleing
					将已经更新的数据改回去
					事务状态由cancling改成cancled
		4.Log Reconciliation
			将事务写成简单的日志，
			
Redis
	数据全部保存在内存中，定期写入磁盘。
	操作都是原子性的。
	
	
Redis和MongoDB比较
	内存管理机制：
		Redis数据全部存在内存，定期写入磁盘，如果内存不够，可以设置LRU（最近最少使用的）算法自动删除数据。
		MongoDB数据存内存，当内存不够时，只会将热点数据存内存，其他数据存磁盘。
	数据类型：
		mongoDB只存json字符串。
		redis有string、hash、list、set等格式
	持久化：
		redis的改动是先写到存到内存，当修改次数满足要求后，再持久化到磁盘。是分离两步骤做的，如果在持久化成功前就重启了系统，可能会造成数据丢失。
		mongoDB每次改动都会保存到磁盘文件中，所以不存在丢失数据的情况，但是性能会下降。
	体积：
		redis初始化很小
		mongoDB很大，和mysql差不多
为什么使用nosql：
	关系型数据库查询慢，扩展难、维护困难。
	海量数据下，读写性能优异。
	数据间没有关系，易于扩展。
	
使用mongoDB：运维设计了一个日志系统，将生产环境产生的所有日志信息全部存到这个系统中，然后通过web输入关键字去查询自己想要的信息，去寻找错误。
使用redis：当做一个缓存工具，有一些数据存数据库表太麻烦，太浪费，就直接存redis里面了。
	
	
	
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		

