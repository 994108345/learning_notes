1.事务套事务，事务是传播机制。
	PROPAGATION_REQUIRED – 如果调用者包含事务，则支持当前事务，一起回滚，如果调用者不支持事务，则自己形成自己的事务域，自己有异常了自己单独回滚。在改配置的方法中，调用了其他方法都会被加入到这个事务中。
		这个也是默认的传播机制；默认事务类型，如果没有，就新建一个事务；如果有，就加入当前事务，也就是大家都使用同一个事务模型，只要有一个发生了异常，那么整个事务都会回滚。
		子事务抛异常，父子事务全部回滚
		父类抛异常，父类子类一起回滚
		传播性为，将多个事务看成一个事务，只要有一个报错，即全部回滚！
		
		
	PROPAGATION_SUPPORTS – 如果调用者存在事务，则支持调用者事务，与调用者事务处于同一份上下文，一起回滚和提交，如果没有，则按没有事务方式运行。
		只要父事务配置了support，则不回滚。
	
	PROPAGATION_MANDATORY – 如果调用者存在事务，则和调用者处于同一事务上下级，一起回滚和提交，如果调用者不存在事务，则报错。（测试与结论不符合）
		父方法配置了事务mandatory，子方法没有配置事务，则一调用就报错！
		父方法配置了事务mandatory，子方法配置了默认事务required，一调用就报错
		父方法没有配置事务，子方法配置了mandatory，不会报错。并且子房里里有异常，也不回滚！
		
		
	PROPAGATION_REQUIRES_NEW – 如果调用者不存在事务，则自己新建一个事务，如果调用者存在一个事务，则把调用者事务挂起，两个事务不处于同一个上下文，各自报错各自回滚。

	PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。即子事务的报错不对父事务有影响。
		可以用于发送提示消息，站内信、短信、邮件提示等。不属于并且不应当影响主体业务逻辑，即使发送失败也不应该对主体业务逻辑回滚。
	
	PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。

	PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。
		基于数据库savepoint实现的嵌套事务，父方法事务的commit和rollback能够控制嵌套子事务，而嵌套子事务报错时，可以选择rollback，返回原始savepoint，父事务继续执行。该传播机制可以解决发生在REQUIRED传播机制下rollback_only的问题（rollback_only的具体场景可以google一下）。父事务回滚，子事务一定回滚，但是子事务回滚，不影响父事务回滚。
		
2.lock和synchronized的区别
	存在层次：synchronized是jvm层面上的，lock是一个类
	锁的释放：sychronized的运行完同步代码即释放锁，lock在finally中必须释放，否则会造成线程死锁。
	锁的状态：sychronized无法判断，lock可以判断。
	锁类型：sychronized有可重入，lock有不可中断，非公平。可重入，可判断，可公平
	选哪个呢：suchronized少量同步，lock大量同步。
3.dubbo和html的区别
	dubbo底层调用据说通过rpc调用，因为良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。和http没有这些优点。
	dubbo底层的基于rpc框架！好好研究研究
4.java8的特性（关注一下java9.java10.新技术还是要关注一下，不求精通起码稍微能懂一些）

5.synorized修饰方法，两个线程类去调用，和一个类按顺序调两个sychronized方法。会怎样？
	是不是我记错了
6.jvm知道哪些 ，说一说
	
7.线程池的使用
	
8.说一说NIO
	